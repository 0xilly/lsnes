  Introduction

lsnes is SNES rerecording emulator based on bsnes core.

  Dependencies

  bsnes libsnes (for bsnes SNES core)

  v084-v087 (v084 or v085 for delayreset support)

  accuracy or compatiblity core with debugger enabled.

  Patched version (using included 7 patches)

  gambatte (for gambatte core)

  SVN r320, r358 or r364

  Patched with included patches

  Zlib

  boost_iostreams

  boost_filesystem

  boost_thread (if native std::thread is not available)

  libsdl (SDL only)

  sdlmain (SDL only, part of SDL)

  boost_conversion (this is header-only library)

  libswscale (wxwidgets graphics only)

  Portaudio (portaudio sound only)

  libao (libao sound only)

  Lua version 5.1.X or 5.2.X

  G++ 4.6 or 4.7

  libopus (optional, for commentary track tool)

  Building

  Copy bsnes sources (the bsnes subdirectory) to subdirectory 
  'bsnes' (for bsnes core).

  Copy gambatte sources to subdirectory 'gambatte' (for gambatte 
  core).

  Patch the bsnes sources with included patches (directory 
  'bsnes-patches/<version>', bsnes core)

  Patch the gambatte sources with included patches (directory 
  'gambatte-patches/<version>', gambatte core)

  Edit options.build (or copy of that file)

  Run make (passing 'OPTIONS=<filename>' if using something else 
  than options.build).

  Command line options

  Wxwidgets options

  --rom=<file>

Load <file> as ROM.

  <file>

Load <file> as ROM.

  --load=<file>

Load <file> as movie or savestate file on startup.

  --settings

Instead of starting the emulator, only display the settings.

  --lua=<file>

Run this Lua file on startup

  dump options (lsnes-dumpavi only)

  --rom=<file>

Load <file> as ROM. Required.

  <filename>

Load <filename> as movie or savestate file on startup. Required.

  --dumper=<dumper>

Set the dumper to use (required). Use 'list' for listing of known 
dumpers.

  --firmware-path=<path>

Set path to look for firmware.

  --mode=<mode>

Set the mode to use (required for dumpers with multiple modes, 
forbidden otherwise). Use 'list' for known modes.

  --prefix=<prefix>

Set dump prefix. Default is “avidump”.

  --option=<name>=<value>

Set option <name> to value <value>.

  --length=<length>

Set number of frames to dump. Mandatory.

  --lua=<script>

Run specified lua script (lsnes-dumpavi does not have 
initialization files).

  --load-library=<library>

Load the specified shared object / dynamic library / dynamic link 
library.

  lsnes settings directory

The lsnes settings directory is (in order of decreasing 
perference):

  Windows: %APPDATA%\lsnes (if %APPDATA% exists)

  Unix: $XDG_CONFIG_HOME/lsnes (if $XDG_CONFIG_HOME exists)

  Unix: $HOME/.config/lsnes (if $HOME exists)

  All: . (fallback default).

If leading directories do not exist, attempt to create them is 
made.

  Internal commands

  Commands beginning with '*' invoke the corresponding command 
  without alias expansion.

  If command starts with '+' (after possible '*'), the command is 
  executed as-is when button is pressed, and when button is 
  released, it is executed with '+' replaced by '-'.

  Commands without '+' execute only on negative edge (release).

  run-script <script>

Run <script> as if commands were entered on the command line.

  Memory manipulation

<address> may be decimal or hexadecimal (prefixed with '0x'). 
<value> can be hexadecimal (prefixed with '0x'), unsigned or 
signed (prefixed with '-') decimal.

The available element <sizes> are:

  byte: 1 byte

  word: 2 bytes

  dword: 4 bytes

  qword: 8 bytes

When reading RAM and ROM, multi-byte reads/writes are big-endian. 
When dealing with DSP memory, multi-byte reads/writes are 
native-endian (do not use operand sizes exceeding DSP bitness, 
except dword is OK for 24-bit memory).

  read-<size> <address>

Read the value of byte in <address>.

  read-s<size> <address>

Read the value of signed byte in <address>.

  write-<size> <address> <value>

Write <value> to byte in address <address>.

  Main commands

These commands are not available in lsnesrc, but are available 
after ROM has been loaded.

  quit-emulator

Quits the emulator.

  pause-emulator

Toggle paused/unpaused

  +advance-frame 

Advance frame. If the button is still held after configurable 
timeout expires, game unpauses for the duration frame advance is 
held.

  +advance-poll 

Advance subframe. If the button is still held after configurable 
timeout expires, game unpauses for the duration frame advance is 
held.

  advance-skiplag 

Skip to first poll in frame after current.

  reset 

Reset the SNES after this frame.

  load <filename> 

Load savestate <filename> in current mode.

  load-state <filename> 

Load savestate <filename> in readwrite mode.

  load-readonly <filename> 

Load savestate <filename> in readonly mode.

  load-preserve <filename> 

Load savestate <filename> in readonly mode, preserving current 
events.

  load-movie <filename> 

Load savestate <filename>, ignoring save part in readonly mode.

  save-state <filename> 

Save system state to <filename> as soon as possible.

  save-movie <filename> 

Save movie to <filename>.

  set-rwmode 

Set read-write mode.

  set-romode 

Set read-only mode

  toggle-rwmode 

Toggle between read-only and read-write modes.

  test-1, test-2, test-3

Internal test commands. Don't use.

  take-screenshot <filename> 

Save screenshot to <filename>.

  +controller <class>-<#>-<button>

Press button <button> on controller <num> of class <class>.

  Class 'gamepad': A, B, X, Y, L, R, select, start, up, down, 
  left, right, ext0, ext1, ext2, ext3

  Class 'mouse': L, R

  Class 'superscope': trigger, cursor, turbo, pause

  Class 'justifier': trigger, start

  Class 'gb': A, B, select, start, up, down, left, right

  hold-controller <class>-<#>-<button>

Hold/unhold button <button> on controller <num> of class <class>.

  type-controller <class>-<#>-<button>

Hold/unhold button <button> on controller <num> of class <class> 
for the next frame. See +controller for button names.

Cauntion: Does not work properly if outside frame advance.

  +autofire-controller <class>-<#>-<button> [[<duty>] <cyclelen>]

Start autofire. If duty is not specified, defaults to 1. If 
<cyclelen> is not specified, defaults to 2.

  -autofire-controller <class>-<#>-<button> [[<duty>] <cyclelen>]

End autofire.

  autofire-controller <class>-<#>-<button> [[<duty>] <cyclelen>]

Toggle autofire. If autofire is turned on, specified cycle is 
used.

  designate-position <class>-<#>-analog<n>

Designate position for analog pair. <n> is only there if there 
are multiple axis pairs.

  repaint

Force a repaint.

  toggle-pause-on-end

Toggle pause on end flag.

  set-pause-on-end

Set pause on end flag.

  clear-pause-on-end

Clear pause on end flag.

  action <action> [<parameters>]

Run specified core action.

  Save jukebox 

  cycle-jukebox-backward

Cycle save jukebox backwards.

  cycle-jukebox-forward

Cycle save jukebox forwards

  load-jukebox

Do load from jukebox (current mode).

  save-jukebox

Do state save to jukebox.

  Lua 

  evaluate-lua <luacode>

Run Lua code <luacode> using built-in Lua interpretter.

  L <luacode>

Synonym for evaluate-lua.

  run-lua <script>

Run specified lua file using built-in Lua interpretter.

  reset-lua

Clear the Lua VM state and restore to factory defaults.

  Memory watch

  add-watch <name> <expression>

Adds new watch (or modifies old one).

  remove-watch <name>

Remove a watch.

  Sound 

  enable-sound <on/off> 

Enable/Disable sound.

  Misc.

  reload-rom [<file>]

Reloads the main ROM image from <file>.

  +tangent

Tangent for recording voice for commentary track. While pressed, 
record a stream.

  advance-subframe-timeout

Subframe advance timeout in milliseconds. Default is 100.

  Settings

  Core settings

  AVI dumper settings

  avi-large

AVI dumper: Always dump at 512x448 or 512x478 regardless of what 
the console outputs.

  avi-left-border

AVI dumper: Set the default left border thickness (unless lua 
overrides) for dumps. Range 0-8191. Default is 0.

  avi-right-border

AVI dumper: Set the default right border thickness (unless lua 
overrides) for dumps. Range 0-8191. Default is 0.

  avi-top-border

AVI dumper: Set the default top border thickness (unless lua 
overrides) for dumps. Range 0-8191. Default is 0.

  avi-bottom-border

AVI dumper: Set the default bottom border thickness (unless lua 
overrides) for dumps. Range 0-8191. Default is 0.

  avi-maxframes

AVI dumper: Maximum number of frames per dump segment (0 => 
unlimited). Range 0-999999999. Default is 0.

  avi-compresison

AVI dumper: Compression level (0-18).

  Compression levels 10 and above are not compatible with stock 
  CSCD codec.

  Recomended level is 7.

  avi-soundrate

AVI dumper: Set method of determining the sound rate.

  0: Pick nearest of 8, 11.025, 12, 16, 22.05, 24, 32, 44.1, 48, 
  64, 88.2, 96, 128, 176.4 and 192 kHz.

  1: Round down to nearest integer.

  2: Round up to nearest ingeter.

  3: Multiply by denominator.

  4: High quality 44.1kHz (SRC needed).

  5: High quality 48kHz (SRC needed).

  JMD options

  jmd-compression

JMD dumper: Compression level (0-9).

  Lua functions

  Core (in main table)

  print

Print line to message console.

  exec(string command)

Run command as it was entered on the command line

  utime()

Returns two values. First is time since some epoch in seconds, 
the second is microseconds mod 10^6 since that epoch.

  emulator_ready()

Returns true if emulator has finished booting, false if not 
(on_startup() will be issued later).

  set_idle_timeout(number timeout)

Set number of microseconds to block idle for. After this timeout 
has expired, on_idle() will be called once.

  set_timer_timeout(number timeout)

Set number of microseconds to block timer for. After this timeout 
has expired, on_timer() will be called once.

  bus_address(number snesaddr)

Returns virtual address corresponding to specified address on 
SNES bus.

  loopwrapper(function fun, ...)

Calls function fun with function and specified arguments. The 
function passed suspends execution until the function returned is 
called. Handy for linear flow control among multiple invocations 
of a hook. Example code:

on_paint = loopwrapper(function(wait)

  while true do

    gui.text(0, 0, “Test!”);

    wait();

  end

end);

  list_bindings([string cmd])

Get table of all keybindings, indexed by keyspec 
(modifiers|mask/key). If command is specified, the table is 
limited to that command. Also searches for controller keys.

  get_alias(string aname)

Get expansion of given alias.

  set_alias(string aname, string value)

Set expansion of given alias.

  create_ibind(string name, string cmd)

Return object representing inverse binding with specified name 
and specified command.

  To create press/release commands, use aliases +foo and -foo .

  Keep the returned object around.

  create_command(string name, function a[, function b])

Return object representing a command (pair).

  If b is NIL, the command is level-sensitive, a is callback.

  If b is function, the function is edge-sensitive, a is positive 
  edge callback and b is negative edge callback.

  All callbacks get single argument: The parameters passed.

  Keep the returned object around.

  Table bit:

Bitwise logical functions and related.

  bit.none(number...) / bit.bnot(number...)

48-bit bitwise NOT / NONE function (set bits that are set in none 
of the arguments).

  bit.any(number...) / bit.bor(number...)

48-bit bitwise OR / ANY function (set bits that are set in any of 
the arguments).

  bit.all(number...) / bit.band(number...)

48-bit bitwise AND / ALL function (set bits that are set in all 
of the arguments).

  bit.parity(number...) / bit.bxor(number...)

48-bit bitwise XOR / PARITY function (set bits that are set in 
odd number of the arguments).

  bit.lrotate(number base[, number amount[, number bits]])

Rotate bits-bit (max 48, default 48) number left by amount 
(default 1) places.

  bit.rrotate(number base[, number amount[, number bits]])

Rotate bits-bit (max 48, default 48) number right by amount 
(default 1) places.

  bit.lshift(number base[, number amount[, number bits]])

Shift bits-bit (max 48, default 48) number left by amount 
(default 1) places. The new bits are filled with zeroes.

  bit.lrshift(number base[, number amount[, number bits]])

Shift bits-bit (max 48, default 48) number logically right by 
amount (default 1) places. The new bits are filled with zeroes.

  bit.arshift(number base[, number amount[, number bits]])

Shift bits-bit (max 48, default 48) number arithmetically right 
by amount (default 1) places. The new bits are shifted in with 
copy of the high bit.

  bit.extract(number base[, number bit0[, number bit1,...]])

Returns number that has bit0-th bit as bit 0, bit1-th bit as 1 
and so on.

Notes: 

  Bit numbers up to 51 should work reliably (then things start 
  falling apart due to double precision issues).

  There are two special bit positions, true and false, standing 
  for always set bit and always clear bit.

  bit.value([number bit1[, number bit2,...]])

Returns bitwise OR of 1 left shifted by bit1 places, 1 left 
shifted by bit2 places and so on. As special value, nil argument 
is no-op.

  bit.test_any(number a, number b)

Returns true if bitwise and of a and b is nonzero, otherwise 
false.

  bit.test_all(number a, number b)

Returns true if bitwise and of a and b is equals b, otherwise 
false.

  bit.popcount(number a)

Returns number of set bits in a.

  bit.clshift(number a, number b, [number amount,[number bits]])

Does chained left shift on a, b by amount positions, assuming 
numbers to be of specified number of bits.

  bit.crshift(number a, number b, [number amount,[number bits]])

Does chained right shift on a, b by amount positions, assuming 
numbers to be of specified number of bits.

  bit.flagdecode(number a, number bits, [string on, [string 
  off]])

Return string of length bits where ith character is ith character 
of on if bit i is on, otherwise ith character of off. Out of 
range reads give last character, or '*'/'-' if empty.

  bit.rflagdecode(number a, number bits, [string on, [string 
  off]])

Like bit.flagdecode, but outputs the string in the opposite order 
(most significant bit first).

  Table gui:

Most of these functions can only be called in on_paint and 
on_video callbacks. Exceptions are noted.

Colors are 32-bit. Bits 0-7 are the blue component, bits 8-15 are 
the green component, bits 16-23 are the red component, bits 24-31 
are alpha component (0 is fully opaque, 255 is almost 
transparent). -1 is the fully transparent color. Alpha values 
greater than 127 do work.

Origin of coordinates is at top left corner of game display area. 
Left and top gaps correspond to negative coordinates.

  gui.resolution()

Returns 2-tuple (hresolution, vresolution).

  gui.<class>_gap(number gap)

Set the <class> (left, right, top, bottom) gap to specified value 
(max gap is 8191). If successful, old gap is returned.

  gui.delta_<class>_gap(number gap)

Increase the <class> (left, right, top, bottom) gap by specified 
value (max gap is 8191) and return the old gap (returns nothing 
on error).

  gui.text(number x, number y, string text[, number fgc[, number 
  bgc]])

Draw specified text on the GUI (each character cell is 8 or 16 
wide and 16 high). Parameters:

  x: X-coordinate to start the drawing from (and x-coordinate at 
  begining of the lines).

  y: Y-coordinate to start the drawing from.

  text: The text to draw.

  fgc: Text color (default is 0xFFFFFF (white))

  bgc: Background color (default is -1 (transparent))

  gui.textH(number x, number y, string text[, number fgc[, number 
  bgc]])

Like gui.text, but draw using double-width.

  gui.textV(number x, number y, string text[, number fgc[, number 
  bgc]])

Like gui.text, but draw using double-height.

  gui.textHV(number x, number y, string text[, number fgc[, 
  number bgc]])

Like gui.text, but draw using double-width/double-height.

  gui.rectangle(number x, number y, number width, number height[, 
  number thickness[, number outline[, number fill]]])

Draw rectangle on the GUI. Parameters:

  x: X-coordinate of left edge.

  y: Y-coordinate of upper edge.

  width: Width of rectangle.

  height: Height of rectangle.

  thickness: Thickness of outline (default is 1).

  outline: Color of outline (default is 0xFFFFFF (white))

  fill: Color of fill (default is -1 (transparent))

  gui.box(number x, number y, number width, number height[, 
  number thickness[, number outline1[,number outline2[, number 
  fill]]]])

Draw rectangle with 3D effect on the GUI. Parameters:

  x: X-coordinate of left edge.

  y: Y-coordinate of upper edge.

  width: Width of rectangle.

  height: Height of rectangle.

  thickness: Thickness of outline (default is 1).

  outline1: First color of outline (default is 0xFFFFFF (white))

  outline2: First color of outline (default is 0x808080 (dark 
  gray))

  fill: Color of fill (default is 0xC0C0C0 (light grayy))

  gui.pixel(number x, number y[, number color])

Draw one pixel on the GUI. Parameters:

  x: X-coordinate of the pixel

  y: Y-coordinate of the pixel

  color: Color of the pixel (default is 0xFFFFFF (white))

  gui.crosshair(number x, number y[, number length[, number 
  color]])

Draw a crosshair. Parameters:

  x: X-coordinate of the crosshair

  y: Y-coordinate of the crosshair

  length: Length of the crosshair lines (default 10).

  color: Color of the crosshair (default is 0xFFFFFF (white))

  gui.line(number x1, number y1, number x2, number y2[, number 
  color])

Draw a thin line. Parameters:

  x1: X-coordinate of one end.

  y1: Y-coordinate of one end.

  x2: X-coordinate of the other end.

  y2: Y-coordinate of the other end.

  color: Color of the line (default is 0xFFFFFF (white)).

  gui.circle(number x, number y, number r[, number thick[, number 
  border[, number fil]]])

Draw a circle. Parameters.

  x: X-coordinate of the center

  y: Y-coordinate of the center

  r: The radius of the circle

  thick: Border thickness

  border: Border color (default is 0xFFFFFF (white))

  fill: Fill color (default is -1 (transparent)).

  gui.bitmap_draw(number x, number y, bitmap bitmap, palette 
  palette)

Draw a bitmap on screen with specified palette. Parameters:

  x: X-coordinate of left edge.

  y: Y-coordinate of top edge.

  bitmap: The bitmap to draw

  palette: The palette to draw the bitmap using.

  gui.bitmap_draw(number x, number y, dbitmap bitmap)

Draw a bitmap on screen. Parameters:

  x: X-coordinate of left edge.

  y: Y-coordinate of top edge.

  bitmap: The bitmap to draw

  gui.palette_new()

Returns a new palette (initially all transparent). Can be used 
anywhere.

  gui.bitmap_new(number w, number h, boolean direct[, bool 
  icolor])

Returns a new bitmap/dbitmap. Can be used anywhere. Parameters:

  w: The width of new bitmap

  h: The height of new bitmap

  direct: If true, the returned bitmap is dbitmap, otherwise 
  bitmap.

  icolor: Initital fill color (defaults to 0 on BITMAP, -1 on 
  DBITMAP)

  gui.bitmap_load(string file)

Returns loaded bitmap/dbitmap (if bitmap, the second return value 
is palette for bitmap). Can be used anywhere. Parameters:

  file: The name of file to load.

  gui.palette_set(palette palette, number index, number color)

Sets color in palette. Can be used anywhere. Parameters:

  palette: The palette to manipulate

  index: Index of color (0-65535).

  color: The color value.

  gui.bitmap_pset(bitmap/dbitmap bitmap, number x, number y, 
  number color)

Sets specified pixel in bitmap. Can be used anywhere. Parameters:

  bitmap: The bitmap to manipulate

  x: The x-coordinate of the pixel.

  y: The y-coordinate of the pixel.

  color: If bitmap is a bitmap, color index (0-65535). Otherwise 
  color value.

  gui.bitmap_size(bitmap/dbitmap bitmap)

Get size of bitmap. Can be used anywhere. Parameters:

  bitmap: The bitmap to query.

The first return is the width, the second is the height.

  gui.bitmap_blit(bitmap/dbitmap dest, number dx, number dy, 
  bitmap/dbitmap src, number sx, number sy, number w, number h[, 
  number ck])

Blit a part of bitmap to another. Can be used anywhere. 
Parameters:

  dest: Destination to blit to.

  dx: left edge of target

  dy: Top edge of target

  src: The source to blit from. Must be of the same type as 
  destination.

  sx: left edge of source

  sy: Top edge of source

  w: Width of region

  h: Height of region.

  ck: Color key. Pixels of this color are not blitted.

  If bitmaps are bitmaps, this is color index of colorkey. Values 
    outside range 0-65535 cause no key to be used as colorkey.

  If bitmaps are dbitmaps, this color value of colorkey.

  May be absent or nil for no colorkey blit.

  gui.bitmap_load_png(string filename)

Load a bitmap from PNG file. Parameters:

  filename: The name of file to load the bitmap frame.

Return value:

  If the PNG is of color type 3 (PALETTE), returns two value. 
  First is BITMAP containing the image data from the PNG and 
  second is PALETTE containg the palette data from the PNG.

  For color types 0 (GRAY), 2 (RGB), 4 (GRAY_ALPHA) and 6 (RGBA), 
  returns one DBITMAP containg the image data loaded from the 
  PNG.

  gui.bitmap_load_pal(string filename)

Load a palette from file. Parameters:

  filename: The name of the file.

The kinds of lines supported

  Blank or just whitespace: Ignored

  First non-whitespace is '#': Ignored

  <r> <g> <b>: Fully opaque color with specified RGB values 
  (0-255)

  <r> <g> <b> <a>: Color with specified RGB values (0-255) and 
  specified alpha (0-256, 0 being fully transparent and 256 fully 
  opaque).

  transparent: Fully transparent color

  gui.bitmap_load_str(string content)

Like gui.bitmap_load, but reads the specified string directly as 
content.

  gui.bitmap_load_png_str(string base64content)

Like gui.bitmap_load_png, but reads the specified string (as 
base64-encoded) directly as content.

  gui.bitmap_load_pal_str(string content)

Like gui.bitmap_load_pal, but reads the specified string directly 
as content.

  gui.repaint()

Request on_repaint() to happen as soon as possible. Can be used 
anywhere.

  gui.subframe_update(boolean on)

Request subframe updates (calling on_paint() on subframes) to 
happen (on=true) or not happen (on=false). Can be used anywhere.

  gui.screenshot(string filename)

Write PNG screenshot of the current frame (no drawings) to 
specified file. Can be used anywhere.

  gui.color(number r, number g, number b[, number a])

Returns color (in notation Lua scripts use) corresponding to 
color (r,g,b), each component in scale 0-255. If a is specified, 
that is alpha (0 is fully transparent, 256(sic) is fully opaque). 
The default alpha is 256.

  gui.status(string name, string value)

Set status field “L[<name>]” to <value> in status area. Can be 
used anywhere.

  gui.rainbow(number step, number steps[, number color])

Perform hue rotation of color <color> (default bright red), by 
<step> steps. The number of steps per full rotation is given by 
absolute value of <steps>.

If <steps> is negative, the rotation will be counterclockwise.

  gui.screenshot(string filename)

Saves a screenshot into specified file.

  gui.renderq_new(number width, number height)

Create render queue with specified reported size and return it.

  gui.renderq_clear(RENDERQUEUE queue)

Clear specified render queue.

  gui.renderq_set(RENDERQUEUE queue)

Switch to specified render queue. Use nil as queue to switch to 
default queue.

  When switched to another queue, all drawing functions work and 
  draw there, even outside on_video/on_paint.

  gui.renderq_run(RENDERQUEUE queue)

Run specified render queue, copying the objects to current render 
queue. 

  Warning: Don't try to run the current render queue.

  gui.loadfont(string filename)

Loads font from specified file (CUSTOMFONT object).

  CUSTOMFONT(number x, number y, string text[, number fgc[, 
  number bgc[, number hlc]]])

Draw string with custom font to screen. The parameters are the 
same as in gui.text, except hlc is the halo color (default is no 
halo). 

  table input

Input handling. Only available in on_input callback.

  input.get(number controller, number index)

Read the specified index (0-11) from specified controller (0-7). 
Notes:

  Uses physical controller numbering. Gamepad in port 2 is 
  controller 4, not 1!

  input.set(number controller, number index, number value)

Write the specified index (0-11) from specified controller (0-7), 
storing value. Notes:

  Uses physical controller numbering. Gamepad in port 2 is 
  controller 4, not 1!

  input.get2(number port, number controller, number index)

Read the specified input tuple.

  Port 0 is system port.

  input.set2(number port, number controller, number index, number 
  value)

Write the specified input tuple.

  Port 0 is system port.

  input.lcid_to_pcid2(number lcid)

Look up physical pcid pair (port, controller) corresponding to 
specified logical controller (1-based). Returns nothing if 
controller does not exist.

  input.port_type(number port)

Return type of specified port.

  input.controller_info(number port, number controller)

Get controller info for specified controller. If controller does 
not exist, returns nil. Otherwise returns a table with following 
fields:

  type (string): Type of the controller.

  class (string): Class of the controller.

  classnum (number): Number of the controller within its class 
  (1-based)

  lcid (number): Logical controller number of the controller.

  button_count (number): Number of buttons on controller

  buttons (array): Array of following info about each button:

  type (string): Type of button. Currently one of “null”, “button”
    , “axis”, “raxis”.

  name (string): Name of button.

  symbol (string): Symbol of button. Only present for type “
    button”.

  hidden (boolean): True if hidden button. 

  input.veto_button()

Signals that the button event should be vetoed. Only valid in 
on_button callback.

  input.geta(number controller)

Get input state for entiere controller. Returns 13 return values.

  1st return value: Bitmask: bit i is set if i:th index is 
  nonzero

  2nd-13th return value: value of i:th index.

  input.seta(number controller, number bitmask, number args...)

Set state for entiere controller. args is up to 12 values for 
indices (overriding values in bitmask if specified).

  input.controllertype(number controller)

Get the type of controller as string. Valid values are:

  gamepad

  mouse

  justifier

  superscope

  input.reset([number cycles])

Execute reset. If cycles is greater than zero, do delayed reset. 
0 (or no value) causes immediate reset.

  Only available with subframe flag false.

  input.raw()

Returns table of tables of all available keys and axes. The first 
table is indexed by key name (platform-dependent!), and the inner 
table has the following fields:

  value: Last reported value for control

  For keys: 1 for pressed, 0 for released.

  For axes: -32767...32767.

  For presure-sensitive buttons: 0...32767.

  For hats: Bitmask: 1=>Up, 2=>Right, 4=>Down, 8=>Left.

  For mouse: Coordinates relative to game area.

  ktype: Type of key (disabled, key, mouse, axis, axis-inverse, 
  hat, pressure-m0, pressure-mp, pressure-0m, pressure-0p, 
  pressure-pm, pressure-p0).

  input.keyhook(string key, boolean state)

Requests that keyhook events to be sent for key (state=true) or 
not sent (state=false).

  input.joyget(number controller)

Returns table for current controls for specified controller. The 
names of fields vary by controller type.

  The buttons have the same name as those are referred to in 
  other contexts in the emulator

  The analog axes are “xaxis” and “yaxis”.

  input.joyset(number controller, table controls)

Set the the state of specified controller to values specified in 
specified table.

  input.lcid_to_pcid(number controller)

Return the physical index, physical port and controller number in 
port for specified (1-based) logical controller.

  Table keyboard

Various keybinding-related functions

  keyboard.bind(string mod, string mask, string key, string cmd)

Bind specified key with specified modifers to specified command.

  keyboard.unbind(string mod, string mask, string key)

Unbind specified key with specified modifers.

  nil does not change value

  true/false (buttons) and integers (axes) force value.

  string (button) inverts the input.

  keyboard.alias(string alias, string expansion)

Set expansion of given command.

  Table subtitle

Subtitle handling

  subtitle.byindex(number i)

Read the frame and length of ith subtitle. Returns nothing if not 
present.

  subtitle.set(number f, number l, string txt)

Set the text of subtitle.

  subtitle.get(number f, number l)

Get the text of subtitle.

  subtitle.delete(number f, number l)

Delete specified subtitle.

  Table hostmemory

Host memory handling (extra memory saved to savestates). Host 
memory starts empty.

  hostmemory.read(number address)

Reads hostmemory slot address. Slot numbers out of range return 
false instead of numeric.

  hostmemory.write(number address, number value)

Writes hostmemory slot with 0-255. Slot numbers out of range 
cause extension of host memory slot space.

  hostmemory.readbyte(number address)

Read unsigned byte (1 element) from given address. Slots out of 
range return false.

  hostmemory.writebyte(number address, number value)

Write unsigned byte (1 element) to given slot. Slot numbers out 
of range cause extension.

  hostmemory.readsbyte(number address)

Read signed byte (1 element) from given address. Slots out of 
range return false.

  hostmemory.writesbyte(number address, number value)

Write signed byte (1 element) to given slot. Slot numbers out of 
range cause extension.

  hostmemory.readword(number address)

Read unsigned word (2 elements) from given address. Slots out of 
range return false.

  hostmemory.writeword(number address, number value)

Write unsigned word (2 elements) to given slot. Slot numbers out 
of range cause extension.

  hostmemory.readsword(number address)

Read signed word (2 elements) from given address. Slots out of 
range return false.

  hostmemory.writesword(number address, number value)

Write signed word (2 elements) to given slot. Slot numbers out of 
range cause extension.

  hostmemory.readdword(number address)

Read unsigned doubleword (4 elements) from given address. Slots 
out of range return false.

  hostmemory.writedword(number address, number value)

Write unsigned doubleword (4 elements) to given slot. Slot 
numbers out of range cause extension.

  hostmemory.readsdword(number address)

Read signed doubleword (4 elements) from given address. Slots out 
of range return false.

  hostmemory.writesdword(number address, number value)

Write signed doubleword (4 elements) to given slot. Slot numbers 
out of range cause extension.

  hostmemory.readqword(number address)

Read unsigned quadword (8 elements) from given address. Slots out 
of range return false.

  hostmemory.writeqword(number address, number value)

Write unsigned quadword (4 elements) to given slot. Slot numbers 
out of range cause extension.

  hostmemory.readsqword(number address)

Read signed quadword (8 elements) from given address. Slots out 
of range return false.

  hostmemory.writesqword(number address, number value)

Write signed quadword (8 elements) to given slot. Slot numbers 
out of range cause extension.

  Table movie

Movie handling

  movie.currentframe()

Return number of current frame.

  movie.framecount()

Return number of frames in movie.

  movie.readonly()

Return true if in readonly mode, false if in readwrite.

  movie.rerecords()

Returns the current value of rerecord count.

  movie.set_readwrite()

Set readwrite mode (does not cause on_readwrite callback).

  movie.frame_subframes(number frame)

Count number of subframes in specified frame (frame numbers are 
1-based) and return that.

  movie.read_subframes(number frame, number subframe)

Read specifed subframe in specified frame and return data as 
array (100 elements, numbered 0-99 currently).

  movie.read_rtc()

Returns the current value of the RTC as a pair (second, 
subsecond).

  movie.unsafe_rewind([UNSAFEREWIND state])

Start setting point for unsafe rewind or jump to point of unsafe 
rewind.

  If called without argument, causes emulator to start process of 
  setting unsafe rewind point. When this has finished, callback 
  on_set_rewind occurs, passing the rewind state to lua script.

  If called with argument, causes emulator rewind to passed 
  rewind point as soon as possible. Readwrite mode is implicitly 
  activated.

The following warnings apply to unsafe rewinding:

  There are no safety checks against misuse (that's what “unsafe” 
  comes from)!

  Only call rewind from timeline rewind point was set from.

  Only call rewind from after the rewind point was set.

  Table settings

Routines for settings manipulation

  settings.get(string name)

Get value of setting. If setting is blank, returns false. If 
setting value can't be obtained, returns (nil, error message).

  settings.set(string name, string value)

Set value of setting. If setting can't be set, returns (nil, 
error message).

  settings.is_set(string name)

Returns if setting is set. If setting does not exist, returns 
(nil, error message).

  settings.blank(string name)

Blanks a setting and returns true. If setting can't be blanked, 
returns (nil, error message).

  Table memory

Contains various functions for managing memory

  memory.vma_count()

Returns the number of VMAs

  memory.read_vma(number index)

Reads the specified VMA (indices start from zero). Trying to read 
invalid VMA gives nil. The read VMA is table with the following 
fields:

  region_name (string): The readable name of the VMA

  baseaddr (number): Base address of the VMA

  lastaddr (number): Last address in the VMA.

  size (number): The size of VMA in bytes.

  readonly (boolean): True of the VMA corresponds to ROM.

  iospace (boolean): True if the VMA is I/O space.

  native_endian (boolean): True if the VMA has native endian as 
  opposed to little endian.

  memory.find_vma(number address)

Finds the VMA containing specified address. Returns table in the 
same format as read_vma or nil if not found.

  memory.readbyte([string vma, ]number address)

Reads the specified address as unsigned byte and returns the 
result.

  memory.readsbyte([string vma, ]number address)

Reads the specified address as signed byte and returns the 
result.

  memory.writebyte([string vma, ]number address, number value)

Writes the specified value (negative values undergo 2's 
complement) to specified address (as a byte).

  memory.readword([string vma, ]number address)

Reads the specified address as unsigned word and returns the 
result.

  memory.readsword([string vma, ]number address)

Reads the specified address as signed word and returns the 
result.

  memory.writeword([string vma, ]number address, number value)

Writes the specified value (negative values undergo 2's 
complement) to specified address (as a word).

  memory.readdword([string vma, ]number address)

Reads the specified address as unsigned doubleword and returns 
the result.

  memory.readsdword([string vma, ]number address)

Reads the specified address as signed doubleword and returns the 
result.

  memory.writedword([string vma, ]number address, number value)

Writes the specified value (negative values undergo 2's 
complement) to specified address (as a doubleword).

  memory.readqword([string vma, ]number address)

Reads the specified address as unsigned quadword and returns the 
result.

  memory.readsqword([string vma, ]number address)

Reads the specified address as signed quadword and returns the 
result.

  memory.writeqword([string vma, ]number address, number value)

Writes the specified value (negative values undergo 2's 
complement) to specified address (as a quadword).

  memory.hash_region([string vma, ]number base, number size)

Hash specified number of bytes starting from specified address 
and return the SHA-256.

  memory.hash_state()

Hash the current system state. Mainly useful for debugging 
savestates.

  memory.readregion([string vma, ]number base, number size)

Read a region of memory.

  Warning: If the region crosses VMA boundary, the results are 
  undefined.

  memory.map<type>([[string vma, ]number base, number size])

Returns a table mapping specified memory aperture for read/write. 
If parameters are omitted, entiere map space is the aperture.

  Type may be one of: byte, sbyte, word, sword, dword, sdword, 
  qword or sqword.

  memory.writeregion([string vma, ]number base, number size, 
  table data)

Write a region of memory.

  Warning: If the region crosses VMA boundary, the results are 
  undefined.

  memory.map_structure()

Returns a new mapping structure (MMAP_STRUCT)

  MMAP_STRUCT(string key, [string vma, ]number address, string 
  type)

Bind key in mmap structure to specified address with specified 
type.

  Type may be one of: byte, sbyte, word, sword, dword, sdword, 
  qword or sqword.

  memory.read_expr(string expr)

Evaluate specified watch expression and return result

  memory.action(string action, [<params>])

Run core action. The different models expect parameters as:

  string: String

  numeric: numeric

  enumeration: String

  boolean: String

  toggle: None.

  memory.get_lag_flag()

Get the value of core lag flag. True if this frame has been lag 
so far, false if poll has been detected.

  memory.set_lag_flag(boolean flag)

Set the value of core lag flag. This flag automatically gets 
cleared if poll is detected, but can be forcibly set if game so 
requires. Should only be used in on_frame_emulated callback.

Setting or clearing this affects the emulator lag counter.

  Table memory2

Contains newer memory functions.

  memory2()

Returns array of all valid VMA names.

  memory2.<vma>:info()

Return table describing given VMA. Includes fields address, size, 
last, readonly, special and endian.

  memory2.<vma>:<op>(number offset)

Read from given VMA at given offset (must be in-range). Op is of 
form:

  [i][s]<type>, where <type> is one of 'byte', 'word', 'dword', 
  'qword'. 'i' signifies that the value is treated as 
  opposite-to-normal endianess, 's' signifies that value is 
  treated as signed.

  memory2.<vma>:<op>(number offset, number value)

Write value to given VMA at given offset (must be in-range). See 
above for form of op.

  Table subtitle

Contains functions for manipulating subtitles.

  subtitle.byindex(number index)

Get (basetime, length) pair of specified subtitle index or 
nothing if index isn't valid.

  subtitle.get(number basetime, number length)

Read the specified subtitle. Returns “” if the subtitle does not 
exist.

  subtitle.set(number basetime, number length, string content)

Set the specified subtitle.

  subtitle.deltete(number basetime, number length)

Delete the specified subtitle.

  Table _SYSTEM

Contains copy of global variables from time of Lua 
initialization. Non-writeable.

  Callbacks

Various callbacks to Lua that can occur.

  Callback: on_paint(bool not_synth)

Called when screen is being painted. Any gui.* calls requiring 
graphic context draw on the screen.

not_synth is true if this hook is being called in response to 
received frame, false otherwise.

  Callback: on_video()

Called when video dump frame is being painted. Any gui.* calls 
requiring graphic context draw on the video.

  Callback: on_frame_emulated()

Called when emulating frame has completed and 
on_paint()/on_video() calls are about to be issued.

  Callback: on_frame()

Called on each starting whole frame.

  Callback: on_startup()

Called when the emulator is starting (lsnes.rc and --run files 
has been run).

  Callback: on_rewind()

Called when rewind movie to beginning has completed.

  Callback: on_pre_load(string name)

Called just before savestate/movie load occurs (note: loads are 
always delayed, so this occurs even when load was initiated by 
lua).

  Callback: on_err_load(string name)

Called if loadstate goes wrong.

  Callback: on_post_load(string name, boolean was_savestate)

Called on successful loadstate. was_savestate gives if this was a 
savestate or a movie.

  Callback: on_pre_save(string name, boolean is_savestate)

Called just before savestate save occurs (note: movie saves are 
synchronous and won't trigger these callbacks if called from 
Lua).

  Callback: on_err_save(string name)

Called if savestate goes wrong.

  Callback: on_post_save(string name, boolean is_savestate)

Called on successful savaestate. is_savestate gives if this was a 
savestate or a movie.

  Callback: on_quit()

Called when emulator is shutting down.

  Callback: on_input(boolean subframe)

Called when emulator is just sending input to bsnes core. 
Warning: This is called even in readonly mode, but the results 
are ignored.

  Callback: on_reset()

Called when SNES is reset.

  Callback: on_readwrite()

Called when moving into readwrite mode as result of “set-rwmode” 
command (note: moving to rwmode by Lua won't trigger this, as per 
recursive entry protection).

  Callback: on_snoop(number port, number controller, number 
  index, number value)

Called each time bsnes asks for input. The value is the final 
value to be sent to bsnes core (readonly mode, autohold and 
autofire have been taken into account). Might be useful when 
translating movies to format suitable for console verification. 
Note: There is no way to modify the value to be sent.

  Not called if callback on_snoop2 is defined.

  Callback: on_snoop2(number port, number controller, number 
  index, number value)

Like on_snoop, but reserves port 0 for system, having first user 
port be port 1.

  Callback: on_keyhook(string keyname, table state)

Sent when key that has keyhook events requested changes state. 
Keyname is name of the key (group) and state is the state (same 
kind as table values in input.raw).

  Callback: on_idle()

Called when requested by set_idle_timeout(), the timeout has 
expired and emulator is waiting.

  Callback: on_timer()

Called when requested by set_idle_timeout() and the timeout has 
expired (regardless if emulator is waiting).

  Callback: on_set_rewind(UNSAFEREWIND r)

Called when unsafe rewind object has been constructed.

  Callback: on_pre_rewind() 

Called just before unsafe rewind is about to occur.

  Callback: on_post_rewind() 

Called just after unsafe rewind has occured.

  Callback: on_button(number port, number controller, number 
  index, string type)

Called on controller button press, with following parameters:

  port: Port number (0 is system)

  controller: Controller within port

  index: Index of button.

  type: Type of event, one of:

  “pressed”: Button was pressed.

  “released”: Button was released.

  “hold”: Held.

  “unhold”: Released from hold.

  “type”: Typing input on button.

  “untype”: Typing input undone.

  “autofire <duty> <cycle>”: Autofire with specifie duty and 
    cycle.

  “autofire”: Stop autofire.

  “analog”: Analog action on axis.

  Movie editor

  The editor edits in-memory movie.

  Because past can't be edited and readwrite mode doesn't allow 
  future, editing only works in read only mode.

  Keyboard triggers the normal hotkeys and bindings.

  Left button actions

  Clicking on cell in future (indicated by lack of redish 
  background) toggles it (if it is a button) or prompts for a 
  value (if it is an axis)

  Dragging vertically toggles sequence of buttons or changes a 
  sequence of axis values.

  Right button actions

The right mouse button pops up a context-sensitive menu:

  Toggle <something>: Toggle this button

  Change <something>: Change this axis value

  Insert frame after: Insert a frame after this frame

  Append frame: Append a frame to movie

  Append frames: Append specified number of frames to movie

  Delete frame: Delete this frame

  Delete subframe: Delete this subframe

  Truncate movie: Delete this subframe and everything after it.

  Scroll to frame: Prompt for a frame and scroll the display to 
  that frame.

  Scroll to current frame: Scroll the display to current position

  Run to frame: Prompts for frame and runs the emulation to that 
  frame.

  Change number of lines visible: Change the height of the movie 
  display (1 to 255).

  Lock scroll to playback: While playing back or rewinding 
  movies, the display will follow if enabled.

  Memory watch expression syntax

Memory watch expressions are in RPN (Reverse Polish Notation). At 
the end of expression, the top entry on stack is taken as the 
final result.

Notations:

  Evaluation order is strictly left to right.

  a is the entry on top of stack

  b is the entry immediately below top of stack

  ; separates values to be pushed (no intermediate pop).

  After end of element, all used stack slots are popped and all 
  results are pushed.

  When pushing multiple values, the pushes occur in order shown.

The following operators are available:

  + : a + b

  - : a - b

  * : a * b

  / : a / b

  % : a % b

  a : atan(a)

  b : read_signed_byte(a)

  c : cos(a)

  d : read_signed_dword(a)

  i : quotent(a / b)

  p :\pi


  q : read_signed_qword(a)

  r : sqrt(a)

  s : sin(a)

  t : tan(a)

  u : a; a

  w : read_signed_word(a)

  A : atan2(a, b)

  B : read_unsigned_byte(a)

  C<number>z : Push number <number> to stack.

  D : read_unsigned_dword(a)

  C0x<number>z : Push number <number> (hexadecimal) to stack.

  H<digit> : Set hexadecimal mode with specified number of digits 
  (use A-G for 10-16 digits).

  Q : read_unsigned_qword(a)

  R<digit> : round a to <digit> digits.

  W : read_unsigned_word(a)

  Example:

C0x007e0878zWC0x007e002czW-

  Push value 0x7e0878 on top of stack (C0x007e0878z).

  Pop the value on top of stack (0x7e0878), read word value at 
  that address and push the result,call it x1 (W).

  Push value 0x7e002c on top of stack (C0x007e002cz).

  Pop the value on top of stack (0x7e002c), read word value at 
  that address and push the result,call it x2 (W).

  Pop the two top numbers on stack, x1 and x2, substract x1 from 
  x2 and push x2 - x1 (-).

  Since the expression ends, the final memory watch result is the 
  top one on stack, which is x2 - x1.

  Modifier and key names:

  wxWidgets platform

  Modifier names:

Following modifier names are known:

  alt

  ctrl

  shift 

  meta

  cmd (Mac OS X only)

  Key names:

Following key names are known:

  back, tab, return, escape, space, exclaim, quotedbl, hash, 
  dollar, percent, ampersand, quote, leftparen, rightparen, 
  asterisk, plus, comma, minus, period, slash, 0, 1, 2, 3, 4, 5, 
  6, 7, 8, 9, colon, semicolon, less, equals, greater, question, 
  at, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, 
  u, v, w, x, y, z, leftbracket, backslash, rightbracket, caret, 
  underscore, backquote, a, b, c, d, e, f, g, h, i, j, k, l, m, 
  n, o, p, q, r, s, t, u, v, w, x, y, z, leftcurly, pipe, 
  rightcurly, tilde, delete, start, lbutton, rbutton, cancel, 
  mbutton, clear, shift, alt, control, menu, pause, capital, end, 
  home, lefT, up, right, down, select, print, execute, snapshot, 
  insert, help, numpad0, numpad1, numpad2, numpad3, numpad4, 
  numpad5, numpad6, numpad7, numpad8, numpad9, multiply, add, 
  separator, subtract, decimal, divide, f1, f2, f3, f4, f5, f6, 
  f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, 
  f20, f21, f22, f23, f24, numlock, scroll, pageup, pagedown, 
  numpad_space, numpad_tab, numpad_enter, numpad_f1, numpad_f2, 
  numpad_f3, numpad_f4, numpad_home, numpad_left, numpad_up, 
  numpad_right, numpad_down, numpad_pageup, numpad_pagedown, 
  numpad_end, numpad_begin, numpad_insert, numpad_delete, 
  numpad_equal, numpad_multiply, numpad_add, numpad_separator, 
  numpad_subtract, numpad_decimal, numpad_divide, windows_left, 
  windows_right, windows_menu, command, special1, special2, 
  special3, special4, special5, special6, special7, special8, 
  special9, special10, special11, special12, special13, 
  special14, special15, special16, special17, special18, 
  special19, special20

  Movie file format

Movie file is .zip archive in itself, normal ZIP archive tools 
work on it (note: If you recompress it, do not use compression 
methods other than store and deflate and especially do not use 
encryption of any kind).

  Detecting clean start/SRAM/Savestate

  If file has member “savestate” it is savestate, otherwise:

  If file has members with names starting “moviesram.” it is 
  movie starting from SRAM, otherwise:

  It is movie starting from clear state.

  Member: gametype

Type of game ROM and region (as one line). Valid values are:


+--------------+---------------------+--------+
|    Value     |       System        | Region |
+--------------+---------------------+--------+
+--------------+---------------------+--------+
|  snes_pal    |     Super NES       |  PAL   |
+--------------+---------------------+--------+
|   sgb_pal    |   Super Game Boy    |  PAL   |
+--------------+---------------------+--------+
|  snes_ntsc   |     Super NES       |  NTSC  |
+--------------+---------------------+--------+
|  sgb_ntsc    |   Super Game Boy    |  NTSC  |
+--------------+---------------------+--------+
|     bsx      | BS-X (non-slotted)  |  NTSC  |
+--------------+---------------------+--------+
| bsxslotted   |   BS-X (slotted)    |  NTSC  |
+--------------+---------------------+--------+
| sufamiturbo  |    Sufami Turbo     |  NTSC  |
+--------------+---------------------+--------+


Frame rates are:


+---------+-----------------+
| Region  | Framerate (fps) |
+---------+-----------------+
+---------+-----------------+
|  PAL    |   322445/6448   |
+---------+-----------------+
|  NTSC   | 10738636/178683 |
+---------+-----------------+


  Member: port1

Contains type of port #1 (as one line). Valid values are 'none', 
'gamepad', 'multitap' and 'mouse'. If not present, defaults to 
'gamepad'.

  Member: port2

Contains type of port #2 (as one line). Valid values are 'none', 
'gamepad', 'multitap', 'mouse', 'superscope', 'justifier' and 
'justifiers'. If not present, defaults to 'none'.

  Member: gamename

Contains name of the game (as one line).

  Member: authors

Contains authors, one per line. Part before '|' is the full name, 
part after is the nickname.

  Member: systemid

Always “lsnes-rr1” (one line). Used to reject other saves.

  Member: controlsversion

Always “0” (one line). Used to identify what controls are there.

  Member: “coreversion”

Contains bsnes core version number (as one line).

  Member: projectid

Contains project ID (as one line). Used to identify if two movies 
are part of the same project.

  Member: {rom,slota,slotb}{,xml}.sha256

Contains SHA-256 of said ROM or ROM mapping file (as one line). 
Absent if corresponding file is absent.

  Member: moviesram.<name>

Raw binary startup SRAM of kind <name>. Only present in 
savestates and movies starting from SRAM.

  Member: saveframe

Contains frame number (as one line) of frame movie was saved on. 
Only present in savestates.

  Member: lagcounter

Current value of lag counter (as one line). Only present in 
savestates.

  Member: pollcounters

Contains poll counters (currently 100 of them), one per line. 
Each line is raw poll count if DRDY is set for it. Otherwise it 
is negative poll count minus one. Only present in savestates.

  Member: hostmemory

Raw binary dump of host memory. Only present in savestates.

  Member: savestate

The raw binary savestate itself. Savestate detection uses this 
file, only present in savestates.

  Member: screenshot

Screenshot of current frame. Only present in savestates. First 2 
bytes are big-endian width of image, rest are 24-bit RGB image 
data. Height of image is inferred from the width and size of 
data.

  Member: sram.<name>

Raw binary SRAM of kind <name> at time of savestate. Only present 
in savestates.

  Member: input

The actual input track, one line per subframe (blank lines are 
skipped).

  If the first byte of each line is '.', ' ', <tab> or '|', then 
  the line is part of same frame as previous, otherwise it starts 
  a new frame.

  First subframe must start a new frame.

Length of movie in frames is number of lines in input file that 
start a new frame.

  Member: subtitles

Subtitle track. Optional.

  Each line is in form <firstframe> <numframes> <text>.

  Linefeed is encoded as \n, backslash is encoded as \\.

  Member: rerecords

Contains textual base-10 rerecord count (as one line; emulator 
just writes this, it doesn't read it) + 1.

  Member: rrdata

This member stores set of load IDs. There is one load ID per 
rerecord (plus one corresponding to start of project).

  This member constists of concatenation of records

  Each record is 2-36 bytes long and can represent 1-16,843,009 
  consequtive IDs.

  IDs are interpretted as 256-bit big-endian integers with 
  warparound.

  Initial predicted ID is all zeroes.

Format of each record is:

  1 byte: Opcode byte. Bits 0-4 are prefix length (prefixlen), 
  bits 5-6 are count length (countlen). Bit 7 is unused.

  32-prefixlen bytes of ID.

  countlen bytes of big-endian count (count).

Records are processed as follows:

  To form the first ID encoded by record, take the first 
  prefixlen bytes predicted ID and append the read ID value to 
  it. The result is the first ID encoded.

  If countlen is 0, record encodes 1 ID.

  If countlen is 1, record encodes 2+count IDs.

  If countlen is 2, record encodes 258+count IDs.

  If countlen is 3, record encodes 65794+count IDs.

  The new predicted ID is the next ID after last one encoded by 
  the record.

The number of rerecords + 1 is equal to the sum of number of IDs 
encoded by all records.

  Member: starttime.second

Movie starting time, second part. Epoch is Unix epoch. Default is 
1,000,000,000.

  Member: starttime.subsecond

Movie starting time, subsecond part. Unit is CPU clocks. Default 
is 0.

  Member: savetime.second

Movie saving time, second part. Default is starttime.second. Only 
present in savestates.

  Member: savetime.subsecond

Movie saving time, subsecond part. Default is 
starttime.subsecond. Only present in savestates.

  lsvs file format (commentary tracks)

  Clusters

  Each cluster is 8kB (8192 bytes) in size.

  Cluster n starts at offset 8192*n in file.

  The following clusters are system special:

  Cluster 0 and all clusters with number multiple of 2048 
    (cluster tables)

  Cluster 1 (superblock)

  Cluster tables

  The cluster table describing cluster n is stored in cluster n & 
  ~0x7FF (zero last 11 bits of n).

  This cluster table consists of 2048 4-byte big-endian integers.

  Each entry describes a cluster in 16MB supercluster, in order.

  The valid values for entries are:

  0x00000000: Free cluster

  0x00000001: Last cluster in chain.

  0xFFFFFFFF: System cluster (cluster tables and superblock)

  (anything else): Number of next cluster in chain. Must not be 
    multiple of 2048.

  Due to limitations of the format, there can be at most 2097052 
  superclusters, giving maximum file size of 16TB.

  Stream table

  The stream table chain always starts in cluster 2.

  Otherwise, it follows normal chaining.

  The stream table consists of 16-byte entries:

  The first 8 bytes of entry give big-endian beginning position 
    of stream in units of 1/48000 s.

  The next 4 bytes of entry give big-endian beginning cluster for 
    control data. 0 here marks the entry as not present.

  The last 4 bytes of entry give big-endian beginning cluster for 
    codec data.

  Stream table clusters are normal clusters, following normal 
  chaining.

  The stream begnning position is not guarenteed unique. There 
  can be multiple streams with the same starting position in the 
  file.

  Stream control data

  The stream control data consists of entries 4 bytes each:

  The first 2 bytes of entry gives big-endian length of packet

  The next byte of entry gives audio length of packet in units of 
    1/400 s.

  The last byte is control byte.

    0 means this entry is not present and the control data ends.

    1 is valid control entry.

  The stream control data can also end by running into end of the 
  readable chain.

  This happens if there happens to be exact multiple of 2048 
    packets in stream and number of packets is nonzero.

  These clusters follow normal chaining.

  Stream codec data

  Stream codec data consists of raw Opus data packets packed back 
  to back with nothing in between.

  Warning: Due to internal limitations, this data must reside in 
  the first 65536 superclusters (that is, the first 1TB of the 
  file).

  Superblock

  The superblock is stored in cluster 1. 

  The first 11 bytes are “sefs-magic”<NUL>.

  The rest are unused.

  This cluster 1 is marked as system special.

  Known ROM extensions

  SNES cartridge ROMs: sfc, smc, swc, fig, ufo, sf2, gd3, gd7, 
  dx2, mgd, mgh.

  DMG cartridge ROMs: dmg, gb.

  GBC cartridge ROMs: cgb, gbc.

  Gamepack files

  The first line must be: “[GAMEPACK FILE]”.

  There is one needed line: “type <systype>”. This sets system 
  type to <systype>. The following system types are valid:

  snes (SNES)

  bsx (BS-X non-slotted)

  bsxslotted (BS-X slotted)

  sufamiturbo (Sufami Turbo)

  sgb (Super Game Boy)

  dmg (Game Boy)

  gbc (Game Boy Color)

  gbc_gba (Game Boy Color with GBA initial register values)

  Optionally a region can be specified: “region <region>”. The 
  following values are valid:

  autodetect (Autodetect region: snes and sgb only)

  ntsc (NTSC: snes, bsx, bsxslotted, sufamiturbo, sgb)

  pal (PAL: snes, sgb)

  world (World: dmg, gbc, gbc_gba)

  ROM images are loaded as: “rom <type> <file>”. The following 
  types are valid:

  rom (Cartridge ROM in snes, dmg, gbc, gbc_gba. BIOS in bsx, 
    bsxslotted, sufamiturbo)

  bsx (Cartridge ROM in bsx, bsxslotted)

  slot-a (Cartridge ROM in sufamiturbo)

  slot-b (Cartridge ROM in sufamiturbo)

  ROM markup can be loaded as: “xml <type> <file>”. The types 
  valid are the same as for ROMs.

  Patches can be loaded as “patch[<offset>] <type> <file>”. The 
  types are the same as for ROMs.

  Offset is given in form [+-]<number>. Usually offset is either 
    +0 or -512.

  Default offset is +0.

  Example:

[GAMEPACK FILE]

type snes

rom rom speedygonzales.sfc

patch-512 rom sonicthehedgehog.ips

  Example 2:

[GAMEPACK FILE]

type sgb

rom rom supergameboy.sfc

rom dmg megamanV.dmg

  Quick'n'dirty encode guide

  Start the emulator and load the ROM and movie file.

  Set large AVI option 'set-setting avi-large on'

  Enable dumping 'dump-avi tmpdump' 

  Unpause and let it run until you want to end dumping.

  Close the emulator (closing the window is the easiest way). Or 
  use 'end-avi'.

  For each tmpdump*.avi file created, on command prompt, do 'x264 
  --crf 10 -o tmpdump_<numbers>.mkv tmpdump_<numbers>.avi'.

  Do 'sox tmpdump.sox tmpdump.ogg rate -v 32000'

  Do 'mkvmerge -o tmpdump_video.mkv tmpdump_0000000.mkv + 
  tmpdump_0000001.mkv + tmpdump_0000002.mkv' (list every 
  tmpdump_<numbers>.mkv, with + in between).

  Do 'mkvmerge -o final.mkv tmpdump_video.mkv tmpdump.ogg'. Now 
  final.mkv contains quick'n'dirty encode.

  Axis configurations for some gamepad types:

  XBox360 controller:

Axes 2 and 5 (joystick<n>axis2 and joystick<n>axis5) should be 
set to pressure-+.

set-axis joystick0axis2 pressure-+

set-axis joystick0axis5 pressure-+

  This is needed for SDL only. EVDEV sets those types correctly.

  PS3 “sixaxis” controller:

Axes 8-19 should be disabled.

set-axis joystick0axis8 disabled

set-axis joystick0axis9 disabled

set-axis joystick0axis10 disabled

set-axis joystick0axis11 disabled

set-axis joystick0axis12 disabled

set-axis joystick0axis13 disabled

set-axis joystick0axis14 disabled

set-axis joystick0axis15 disabled

set-axis joystick0axis16 disabled

set-axis joystick0axis17 disabled

set-axis joystick0axis18 disabled

set-axis joystick0axis19 disabled

  Errata:

  Problems from BSNES core:

  The whole pending save stuff.

  Lack of layer hiding.

  It is slow (especially accuracy).

  Firmwares can't be loaded from ZIP archives.

  Other problems:

  Modifiers don't work with pseudo-keys (SDL, EVDEV).

  Audio for last dumped frame is not itself dumped.

  Audio in UI is pretty bad in quality if game doesn't run at 
  full speed.

  No menus, command based interface (SDL).

  Long commands don't scroll.

  Changelog:

  rr0-beta1

  Fix -Wall warnings

  Fix dumper video corruption with levels 10-18.

  rr0-beta2

  Autofire

  Lots of code cleanups

  Lua interface to settings

  Allow specifying AVI borders without Lua

  Fix scaling if vscale > 1 and originx > 0 (left border exists)

  on_snoop lua callback

  Faster movie loading and saving.

  rr0-beta3

  Joystick support

  rr0-beta4

  Fix multi-buttons

  Save jukebox functionality.

  rr0-beta5

  Try to fix some nasty failing movie load edge cases

  Allow specifying scripts to run on command line.

  rr0-beta6

  Major source code reorganization.

  Backup savestates before overwriting.

  Don't crash if loading initial state fails.

  rr0-beta7

  Fix firmware lookup

  Fix author name parsing

  Fix rerecord counting

  (SDL) Print messages to console if SDL is uninitialized

  Add movieinfo program

  Fix loading movies starting from SRAM.

  rr0-beta8

  Add support for unattended dumping

  Fix compiling for Win32

  Don't lock up if sound can't be initialized

  Strip trailing CR from commands

  Don't try to do dubious things in global ctors (fix crash on 
  startup)

  rr0-beta9

  Small documentation tweaking

  Fix make clean

  Fix major bug in modifier matching

  rr0-beta10

  Lots of documentation fixes

  Use dedicated callbacks for event backcomm., not commands.

  Ensure that the watchdog is not hit when executing delayed 
  reset.

  Remove errant tab from joystick message.

  rr0-beta11

  Make autofire operate in absolute time, not linear time

  Reinitialize controls when resuming from loadstate

  Some more code cleanups

  If Lua allocator fails, call OOM_panic()

  Byte/word/dword/qword sized host memory write/read functions.

  Dump at correct framerate if dumping interlaced NTSC 
  (height=448).

  rr0-beta12

  Actually include the complete source code

  Keep track of RTC

  rr0-beta13

  Document {save,start}time.{,sub}second.

  Intercept time() from bsnes core.

  rr0-beta14

  Allow disabling time() interception (allow build on Mac OS X)

  Use SDLMain on Mac OS X (make SDL not crash)

  Disable delayed resets (just plain too buggy for now).

  Code cleanups

  Use 16-bit for graphics/video instead of 32-bit.

  gui.rectangle/gui.pixel

  gui.crosshair

  New CSCD writer implementation.

  rr0-beta15

  Fix interaction of * and +.

  Manual improvements

  Use gettimeofday()/usleep(), these seem portable enough.

  Move joystick axis manipulation to keymapper code.

  Changes to how read-only works.

  Refactor controller input code.

  rr0-beta16

  Fix mouseclick scale compensation.

  Draw area boundaries correctly in SDL code.

  gui.screenshot.

  Fix CSCD output (buffer overrun and race condition).

  rr0-beta17

  JMD dumping support.

  Allow unattended dumping to JMD.

  Move to BSNES v083.

  Switch back to 32-bit colors.

  Add Lua function gui.color.

  Use some new C++11 features in GCC 4.6.

  Be prepared for core frequency changes.

  Pass colors in one chunk from Lua.

  rr0-beta18

  New lua functions gui.line(), gui.status() and gui.circle(), 
  memory.vma_count(), memory.read_vma() and memory.find_vma().

  Numerious documentation fixups

  RTC time format changed

  Reformat flags display

  Allow lua package name to be overridden

  SDUMP (high-quality dumping).

  Split platform support to plugins.

  Make all sound plugins support basic sound commands

  Support portaudio for sound.

  Allow disable Lua/SDL searching.

  Upconvert colors when copying lcscreen to screen.

  Reorganize source tree.

  Evdev joystick support.

  Refactor more code into generic window code.

  rr0-beta19

  Refactor message handling.

  Rework makefile

  Documentation fixes

  Finish pending saves before load/quit.

  Wxwidgets graphics plugin.

  rr0-beta20

  Get rid of win32-crap.[ch]pp.

  Move files around a lot.

  Get rid of need for host C++ compiler.

  Bsnes v084 core.

  Refactor inter-component communication.

  Fix zero luma.

  Fix crash on multiline aliases.

  Load/Save settings in wxwidgets gui.

  rr0-beta21

  Patch problems in bsnes core

  SNES is little-endian, not big-endian!

  Fix memory corruption in lcscreen::load()

  rr0-beta22

  Fix interpretting repeat counts in rrdata loading.

  New lua callback: on_frame()

  Remove calls to runtosave() that aren't supposed to be there

  Lua function: movie.read_rtc()

  Ignore src/fonts/font.cpp

  Fix more bsnes core problems

  Control bsnes random seeding

  Pause-on-end

  Some bsnes core debugging features (state dump and state hash)

  Fix titlebar version number (no, the last version wasn't 
  'lsnes-0-beta21', it was 'lsnes rr0-beta21').

  rr0-beta23

  Fix memory corruption due to macro/field mixup

  search-memory update

  Allow direct-mapped framebuffer

  SDL: Use SDL_ANYFORMAT if possible

  SDMP2SOX: 2s delay modes.

  Wxwidgets: Cleanups

  Use sed -E, not sed -r. Fixes building on Mac OS X.

  Wxwidgets: Save jukebox on exit

  Fix RTC if using load-movie on savestate.

  Fix crash related to full console mode.

  rr0-beta24

  Wxwidgets: Allow bringing application to foreground on Mac OS 
  X.

  Wxwidgets: Allow compiling on Mac OS X.

  Use movie compare instead of movie hashing (faster save/load).

  Lua: _SYSTEM table.

  rr0-beta25

  sdmp2sox: Pad soundtrack if using -l or -L.

  sdmp2sox: Fix NTSC overscan.

  sdmp2sox: Add AR correction mode.

  call lua_close() when exiting.

  Fix zip_writer bug causing warnings from info-zip and error 
  from advzip.

  rr0-beta26

  Fix IPS patching code (use bsnes core IPS patcher).

  Implement BPS patching (using bsnes core IPS patcher).

  Add feature to load headered ROMs.

  rr0-beta27

  Show command names when showing keybindings

  rr0

  Fix pause-on-end to be actually controllable

  SDL: Poll all events in queue, not just first one (fixes 
  slowness in command typing)

  Wxwidgets: Fix ROM loading.

  rr1-beta0

  Lua: Add gui.textH, gui.textV, gui.textHV

  Fix text colors on SDL on Mac OS X

  Mode 'F' for finished in readonly mode.

  Fix some WS errors.

  Reliably pause after skip poll

  Split UI and core into their own threads

  rr1-beta1

  Remove leftover dummy SRAM slot

  Fix controller numbers.

  rr1-beta2

  Fix lsnes-dumpavi after interface change.

  Also give BSNES patches for v085.

  Pack movie data in memory.

  rr1-beta3

  Fix framecount/length given when loading movies.

  Controller command memory leak fixes.

  Don't leak palette if freeing screen object.

  rr1-beta4

  Detect revisions.

  Wxwidgets: Allow controlling dumper from the menu.

  rr1-beta5

  Rewrite parts of manual

  Lua: Make it work with Lua 5.2.

  rr1-beta6

  Win32: Fix compile errors.

  rr1-beta7

  Refactor controller input code.

  Fix crash when using command line on SDL / Mac OS X.

  rr1-beta8

  Delete core/coroutine (obsolete)

  Lag input display by one frame.

  Rewind movie to beginning function.

  Fix wrong frame number reported to Lua when repainting after 
  loadstate

  Support UI editing of jukebox

  Wxwidgets: Save settings on exit.

  Support ${project} for filenames

  SDL: Fix command history

  rr1-beta9

  Fix some order-of-global-ctor bugs.

  rr1-beta10

  Fix crashes when quitting on Win32.

  rr1-beta11

  EVDEV: Queue keypresses from joystick, don't send directly

  Wxwidgets: Load-Preserve that actually works.

  rr1-beta12

  Wxwidgets: GUI for memory search.

  Warn about using synchronous queue in UI callback.

  rr1-beta13

  Remember last saved file for each ROM

  Support MT dumping via boost.

  Lua: input.raw

  Lua: input.keyhook

  Make mouse be ordinary input instead of special-casing

  SDL: Don't screw up commands with NUL codepoints.

  rr1-beta14

  Merge status panel and main window

  True movie slot support (the rest of it)

  SDL: Fix compilation error

  Elminate cross calls in dump menu code.

  rr1-beta15

  Cancel pending saves command

  Wxwidgets: Code refactoring

  Wxwidgets: Fix system -> reset

  Wxwidgets: Read watch expressions in the right thread

  rr1-beta16

  Wxwidgets: Don't prompt for member when running Lua script (Lua 
  doesn't support that).

  Wxwidgets: 128 -> 1024 Autohold slots (in case more are 
  needed).

  Don't append trailing '-' to prefix when saving movie.

  Fix ROM/savestate handling (don't let user mismatch ROM and 
  savestates).

  rr1

  Document memory watch syntax.

  rr1-delta1

  Fix unattended dumping (lsnes-dumpavi)

  Support RAW dumping

  Use adv_dumper instead of the old interface in lsnes-dumpavi 
  (changes syntax)

  Add option to control sample rate preturbation in AVI dumper

  rr1-delta2

  Wxwidgets: Fix dumper submodes

  Set core controller types before loadstate

  rr1-delta2epsilon1

  Fix compiling with bsnes v086.

  rr1-delta3

  Don't prompt before quitting

  Start unpaused, preserve pause/unpause over load.

  Try to autodetect if ROM is headered.

  Wxwidgets: Only bring up ROM patching screen if specifically 
  requested.

  Allow configuring some hotkeys.

  rr1-delta4

  Lots of code cleanups

  Fix JMD compression (JMD dumping was broken)

  Don't crash if Lua C function throws an exception.

  Support bitmap drawing in Lua.

  Fix bsnes v085/v086 patches.

  Improve stability on win32.

  rr1-delta4epsilon1

  Don't corrupt movie if movie length is integer multiple of 
  frames per page.

  rr1-delta5

  New Lua hooks: on_rewind, on_frame_emulated, on_idle, on_timer

  New Lua functions: emulator_ready(), utime(), 
  set_idle_timeout(), set_timer_timeout(), bit.extract(), 
  bit.value(), input.geta(), input.seta() and 
  input.controllertype()

  Wxwidgets: Fix internal focus lost (hotkeys stop working)

  Wxwidgets: Fix broken modifiers

  on_paint has parameter now.

  Optional initital fill for bitmaps

  Fix palette changing.

  Optimize rendering a bit.

  Bsnes v087 support.

  rr1-delta5epsilon1

  Movieinfo: Fix display of port #2 type.

  Call on_input() after loadstate.

  rr1-delta5epsilon2

  Fix writing port2 data to movie.

  Fix SRAM handling with Bsnes v087.

  rr1-delta6

  Library loading support

  Built-in TSCC encoder

  Hi-color (256T colors) dumping.

  Dump over TCP/IP(v6)

  Hidable status panel

  Turbo toggle/hold

  Adjustable sound volume

  Screen scaling

  Allow DnD into filename boxes

  Configurable paths

  Portaudio: Fix speaker popping at start

  Lots of UI changes

  Speed adjustment menu

  Win32 joystick support

  Lua: gui.rainbow and gui.box

  Split key lists into classes (the key list was large!)

  More save slots support

  Wxwidgets (wxJoystick) joystick support

  rr1-delta7

  Lots of internal joystick refactoring

  Evdev: Add mapping for BTN_TOOL_QUINTTAP

  Wxwidgets: Settings mode (open settings without ROM)

  Wxwidgets: Prompt key to use option

  Wxwidgets: Fix crash if key goes away underneath

  Wxwidgets: Fix mouse position in presence of scaling

  AVI dumper: Mode 4 (high-quality resampling to common rate 
  using SRC)

  Wxwidgets: Redesign hotkeys dialog to avoid tree control (tree 
  control doesn't seem to work well on WinXP)

  Start paused option.

  rr1-delta7epsilon1

  AVI: ZMBV support

  lsnes-dumpavi: Start Lua before starting dumper

  AVI: Fix secondary audio in mode 4.

  rr1-delta7epsilon2

  AVI: Refactor ZMBV a bit.

  Fix error reading analog values from movie file

  rr1-delta8

  Delayed reset support

  Lua: memory.hash_region

  rr1-delta8epsilon1

  Rework the build system

  Typing input support

  Fix building with bsnes v086 and v087.

  SDL: Save settings on exit

  SDL: Command to enter command line mode with given command.

  SDL: More advanced command editing.

  rr1-delta9

  wxMSW: Fix the “arrow keys and enter don't work” problem

  MSU-1 support

  Show mode changes due to rewinding.

  Unsafe rewind support

  Fix directory transversal.

  rr1-delta10

  AVI: Sound mode 5 (48kHz high-quality)

  Lua: Reset Lua VM

  Map the SNES bus into address space

  Fix loading memory watch files with CRLF line endings

  rr1-delta10epsilon1

  Map bsnes internal state into memory space

  Fix the “click on panel wedges the emulator” for real.

  DnD movies/saves on the main window.

  rr1-delta11

  Split core bindings into own module.

  Remember invalid settings

  Support for modified Gambatte core for GB/GBC emulation.

  Reload/swap ROM function

  rr1-delta11epsilon1

  Fix step poll function

  rr1-delta12

  Non-insane savestate anchoring

  rr1-delta13

  More Memory search methods

  Preserve movie if loading in RO mode.

  Fix a obscure case in timeline check

  Revamp the entiere ROM loading code

  Support DnD on ROMs

  Revamp menu layout

  Standalone hotkey config dialog

  Show bindings in more user-friendly format

  rr1-delta13epsilon1

  Pipedec support

  Fix uninitialized variables in bsnes v085

  rr1-delta14

  Merge gambatte core into mainline (from its own branch)

  Wxwidgets: Show expected dump file formats

  Memory watch: Data typing

  lsnes internal MMIO area.

  Wxwidgets: New memory watch editor

  Hexadecimal memory watches

  Wxwidgets: Monospaced panel

  Wxwidgets: Split memory watches in panel

  Wxwidgets: Disable VMAs in memory search

  lsnes-dumpavi: Fix speed bug

  Movie subtitle support

  Fix rerecord count reporting

  Don't trash movie when loading in readonly mode.

  rr1-delta14epsilon1

  Wxwidgets: Fix crashes on closing settings dialogs on Mac OS X.

  Fix build on Mac OS X.

  Lua: loopwrapper

  Wxwidgets: Hidable messages window

  Lua: input.joyset

  Bsnes: Support inconsistent saves

  Bsnes: Allow simulating saving every frame

  Fix desync if savestate is loaded in readonly mode in certain 
  conditions.

  Wxwidgets: Fix save dialogs on Mac OS X.

  Wxwidgets: Fix insane status width on Win32.

  Wxwidgets: Fix autohold processing to be faster.

  Wxwidgets: Allow loading ROMs and movies from commandline.

  rr1-delta15

  Be a bit smarter with --load

  Rewrote higher-level parts of audio system

  Tool to build commentary tracks

  Lua: input.joyget

  Gambatte: Add support for SVN358

  Use builtin font when rendering status panel.

  Option to detach memory watch to its own window.

  Recent ROMs/Movies menu

  Libao support

  Useful lag counter for SNES games that autopoll

  Fix buffer overflow in gambatte sound output

  rr1-delta15epsilon1

  Don't blow up on wxGTK if the window is hidden somehow

  Support simultaneous drop of ROM and movie.

  Gambatte: Don't save spurious SRAMs.

  Make SGB ROMs actually usable.

  Fix so that saved movies appear in recent movies.

  Don't open multiple commentary editors at once.

  rr1-delta15epsilon2

  Lua: memory.readregion/memory.writeregion

  Lua: memory.map{,s}{byte,word,dword,qword}

  Lua: memory.map_structure

  Lua: Fix bus_address for gambatte

  Fix features dependent of bsnes debugger

  Cleanup bsnes debugger logic

  Fix resets in presence of save every frame

  rr1-delta15epsilon3

  Lua: input.lcid_to_pcid

  Fix off-by-one bug with slot hashes

  Fix crashes on certain memory watch expressions

  Lua: memory.read_expr

  Lua: Fix memory.read_expr on nil argument

  Fix the code to compile on G++ 4.7

  Change button_id to be a function pointer field, not a virtual 
  method

  Add bsnes patches to fix libsnes to compile on GCC 4.7

  Gambatte: Always use legacy lag counting

  Memory commands: Memory addresses are up to 16 hex digits, not 
  up to 8

  Fix analog controllers

  Fix autohold menus

  Fix button symbols in input display

  Compensate for nuts bsnes superscope/justifier handling

  Lua: Fix bit.extract boolean handling

  rr2-beta0

  Split emulation cores more from the rest

  Support having multiple emulation cores compiled at once

  Support arbitrary number of ports (well, up to 31 anyway).

  SNES debugger support

  Support 16-button controllers

  Remove old SDL front end

  Data-driven controller buttons

  Generate the port code from defines

  rr2-beta1

  Update libgambatte to SVN364

  Get rid of partial linking (building with MXE works)

  Load XML even without gamepack files

  Support screen rotate & flip

  Fix bug when changing controller key to another subkey of the 
  same key

  rr1-delta16

  Stop at movie end: Don't off-by-one

  Fix crash closing lsnes with voice playback active.

  Import/Export OggOpus for commentary tracks

  16-button controllers.

  Don't show nonexistent controllers in input display

  Set voice record/playback volume from UI

  Patches for gambatte SVN364.

  Load markup (if exists) even without gamepack file.

  Screen rotation & flipping

  Lua: Some new bit functions

  Auto-refresh voice streams on change.

  Auto-refresh subtitles on change & new subtitle editor.

  Fix music volume adjustment.

  rr2-beta2

  Use system threads instead of platform threads

  Cleanup build by allowing dummy and real drivers to link 
  together.

  Split duplex support

  rr1-delta16epsilon1

  Wxwidgets: Fix memory watch rendering.

  Wxwidgets: Allow setting voice stream gain.

  Wxwidgets: VU meters and volume adjustment.

  Lua: Custom fonts support.

  Lua: Fix methods stopping working when resetting Lua.

  Fix loading standard-format movies in preserve (readonly) mode.

  rr1-delta17

  Primitive movie editor

  Fix VU meter with no sound device.

  Fix various undefined return values.

  Show rates in VU meter window.

  rr2-beta3

  Lua: Render queues as objects

  Bsnes: support hard resets

  Dedicated sound devices dialog

  Change the default AVI sound mode to 2 or 5.

  Fix totally borked movie saving.

  Portaudio: Use split duplex with different devices.

  Fix controls with gambatte core.

  Modify save slot set handling.

  lsnes-dumpavi: --firmware-path.

  Fix lots of compiler warnings.

  rr1-delta17epsilon1

  Commentary tool: Set nominal bit rate and limit max bit rate.

  Lua: Unconditionally reload host memory on loadstate

  Lua: Query bindings, manipulate aliases, create inverse 
  bindings

  Lua: Fix crashes with resetting VM while some types of paint 
  requests are in flight.

  Lua: gui.text: Clip the text properly instead of corrupting 
  memory in some cases.

  Save screenshot header reliably

  Lua: Backport input.get2 and input.set2

  Lua: New controller info functions.

  Movie editor: Fix reset delay counters to be the right way 
  around.

  Lua: on_snoop2

  Lua: on_button and input.veto_button.

  rr2-beta4

  Revert memory leak fix breaking input

  Refactor Opus handling

  Restrict member picking only to .zip files

  Fix reading of host-endian VMAs.

  Fix rlow and rhigh to be the right way around.

  Lua: Don't wedge VM if callback fails with an exception

  Refactor Ogg handling.

  rr1-delta17epsilon2

  Fix saving PNG screenshots on Win32.

  Movie editor: Sweep axis.

  Load selected slot in ro/rw/preserve/movie mode.

  input.joyset: Preserve and invert user input.

  Allow immediate saving at point of save (transfer saves).

  Wxwidgets: Filter filenames in dialogs, autoappend extensions.

  data/verysmall.font: Add missing glyph 70 (“F”).

  Lua: Allow painting custom fonts with halo.

  Fix memory value search to work on byte types.

  rr2-beta5

  Reject oggopus files with incomplete pregap

  Fix multistream and ogg demuxing

  Workaround bug with screen >1024 pixels wide.

  Allow on_input to force/veto system controls.

  Dedicated autohold/autofire window.

  Support per-button autofire.

  Fix crash on trying to frameadvance/exit with no ROM loaded.

  Fix nonexistent controller key warnings.

  Movie editor: Fix mouse editing (TYPE_RAXIS)

  TAS input plugin

  Analog passthrough.

  Add throttle axes (TYPE_TAXIS).

  Fix movie reading with first port having multiple controllers.

  Move some info from status panel to statusbar.

  rr1-delta17epsilon3

  Fix status panel (and movie editor) flicker

  Show effects of Lua in input display

  Offer lsmv.backup as file filter too for load lsmv

  Allow slowing down subframe advance 

  Display current save slot information

  Add snes9x fonts

  Fix hotkeys stopping working after X-ing settings dialog

  Movie editor: Fix bug if extending finished movie

  Cap current_frame_first_subframe to movie size when recounting 
  movie

  Movie editor: Interpret ctrl+click as right click 

  rr2-beta6

  Autofire: Fix false status indications

  Fix subframe counter

  Fix print() after Lua reset

  New settings framework

  Remove some unused leftover stuff

  Fix race condition causing possible crash on startup

  Fix compiling if uint64_t and size_t are not compatible

  Lua: Don't crash if input.[gs]et{,a} is called outside on_input

  rr2-beta7

  Fix bug causing crash if triple has invalid button

